<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Suza Music Player</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet"/>
    <style>
        /* Global Styles */
        :root {
            --mini-player-height: 65px;
            --nav-height: 55px;
            --primary-bg: #121212;
            --secondary-bg: #1e1e1e;
            --tertiary-bg: #282828;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --accent-color: #1DB954; /* Spotify Green */
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body, html {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-primary);
        }
        /* Hide scrollbar */
        body::-webkit-scrollbar { display: none; }
        body { -ms-overflow-style: none; scrollbar-width: none; }

        /* Page Containers */
        .page {
            display: none; /* Hidden by default */
            padding: 15px;
            padding-bottom: calc(var(--nav-height) + 15px); /* Space for bottom nav */
            min-height: 100vh;
             overflow-y: auto; /* Allow pages to scroll */
        }
        .page.active { display: block; }

        /* Adjust padding for pages when mini-player is active */
        body.mini-player-visible .page {
            padding-bottom: calc(var(--nav-height) + var(--mini-player-height) + 15px);
        }


        /* Loading Indicator */
        .loading-indicator {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            display: none; /* Hidden by default */
        }
        .loading-indicator.active { display: block; }

        /* Song Item Styling (reusable for vertical lists) */
        .song-list { list-style: none; padding: 0; margin: 0; }
        .song-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--tertiary-bg);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .song-item:hover { background-color: var(--secondary-bg); }
        .song-item img {
            width: 50px;
            height: 50px;
            border-radius: 4px;
            margin-right: 15px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .song-item .song-info {
            overflow: hidden; /* Prevent text overflow */
            flex-grow: 1; /* Allow info to take available space */
        }
        .song-item .song-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .song-item .song-artist {
            font-size: 0.85em;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
         .song-item .remove-fav-btn {
             margin-left: auto; /* Push button to the right */
             background: none;
             border: none;
             color: var(--text-secondary);
             font-size: 1.2em;
             cursor: pointer;
             padding: 5px;
             flex-shrink: 0; /* Prevent shrinking */
         }
         .song-item .remove-fav-btn:hover { color: tomato; }

        /* Horizontal Scroll List Styles (for Home page hero) */
         .horizontal-scroll-list {
             display: flex;
             overflow-x: auto;
             gap: 15px; /* Space between items */
             padding: 10px 0; /* Add some vertical padding if needed */
             margin-bottom: 20px; /* Space below the section */
             /* Hide scrollbar */
             scrollbar-width: none; /* Firefox */
         }
         .horizontal-scroll-list::-webkit-scrollbar { display: none; /* Webkit */ }

         .horizontal-scroll-item {
             flex-shrink: 0; /* Prevent items from shrinking */
             width: 130px; /* Fixed width for each item */
             text-align: center;
             cursor: pointer;
             color: var(--text-primary);
             text-decoration: none; /* If using links */
         }
          .horizontal-scroll-item img {
              width: 100%;
              aspect-ratio: 1 / 1; /* Make image square */
              border-radius: 8px;
              object-fit: cover;
              margin-bottom: 5px;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
          }
         .horizontal-scroll-item .song-name {
             font-size: 0.9em;
             font-weight: 500;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             margin-bottom: 2px;
         }
          .horizontal-scroll-item .song-artist {
              font-size: 0.75em;
              color: var(--text-secondary);
              white-space: nowrap;
              overflow: hidden;
              text-overflow: ellipsis;
          }

        /* Bottom Navigation */
        .bottom-nav{
          background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      border-top: 1px solid #444;
      padding: 10px 0;
      font-size: 15px;
      height: 60px;
      z-index: 1000;
      position: fixed;
      bottom: 0;
      width: 100%;
      display: flex;
      justify-content: space-around;
      align-items: center;
        }
        .nav-button {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 12px;
            text-align: center;
            cursor: pointer;
            transition: color 0.2s ease;
            padding: 5px;
             flex-grow: 1; /* Distribute space evenly */
        }
        .nav-button i { font-size: 22px; display: block; margin-bottom: 2px; }
        .nav-button.active, .nav-button:hover { color: var(--theme-color, cyan); }

        /* Big Player Styles */
        #playerPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--secondary-bg); /* Darker background */
            z-index: 20; /* Highest */
            display: none; /* Controlled by JS */
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically */
            padding: 30px 20px;
            overflow-y: auto; /* Allow scrolling if content is too tall */
             -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        #playerPage.active { display: flex; }
        #playerBlurBackground {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-size: cover;
             background-position: center;
             filter: blur(40px) brightness(0.5);
             z-index: -1;
             opacity: 0.7;
        }
        #playerSongImage {
            width: 70%;
            max-width: 280px;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            object-fit: cover;
            margin-bottom: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
             flex-shrink: 0; /* Prevent image from shrinking */
        }
        #playerSongDetails { text-align: center; margin-bottom: 20px; flex-shrink: 0; }
        #playerSongName { font-size: 1.4em; font-weight: 600; margin-bottom: 5px; }
        #playerSongArtist { font-size: 1em; color: var(--text-secondary); }
        #playerProgressContainer {
            width: 100%;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            cursor: pointer;
            margin-bottom: 8px;
             flex-shrink: 0;
        }
        #playerProgressBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--theme-color, #00ffff), var(--theme-second-color, #00d4ff));
            border-radius: 3px;
            transition: width 0.1s linear;
        }
        #playerTimeDisplay {
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-bottom: 25px;
             flex-shrink: 0;
        }
        #playerControlsPrimary {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            max-width: 350px;
            margin-bottom: 30px;
             flex-shrink: 0;
        }
        .player-ctrl-btn {
            background: none;
            border: none;
            color:linear-gradient(90deg, var(--theme-color, #00ffff), var(--theme-second-color, #00d4ff));
            cursor: pointer;
            font-size: 1.8em; /* Smaller side buttons */
            transition: transform 0.1s ease;
        }
        #playerControlsPrimary i {
    color:linear-gradient(90deg, var(--theme-color, #00ffff), var(--theme-second-color, #00d4ff));/* Ya koi bhi color jaise #00ff00, blue, etc. */
}
        .player-ctrl-btn:active { transform: scale(0.9); }
        #playPauseBtn { font-size: 2.8em; /* Larger play/pause */ }
        #playerControlsSecondary {
             display: flex;
             justify-content: space-between;
             align-items: center;
             width: 100%;
             max-width: 300px; /* Slightly narrower */
             margin-top: 10px; /* Space above secondary controls */
             flex-shrink: 0;
         }
         .player-ctrl-btn-secondary {
              background: none;
              border: none;
              color: var(--text-secondary); /* Less prominent */
              cursor: pointer;
              font-size: 1.5em;
              transition: color 0.2s ease;
          }
          .player-ctrl-btn-secondary:hover,
          .player-ctrl-btn-secondary.active { color: var(--accent-color); } /* Highlight active/hover */


        /* Mini Player Styles */
        #miniPlayer {
            position: fixed;
            bottom: var(--nav-height); /* Position above nav bar */
            left: 0;
            width: 100%;
            height: var(--mini-player-height);
            background-color: var(--tertiary-bg);
            z-index: 10; /* Above nav and page content */
            display: none; /* Hidden by default */
            align-items: center;
            padding: 0 15px;
            cursor: pointer;
            border-top: 1px solid #444;
        }
        #miniPlayer.active { display: flex; }
         #miniPlayerInfo {
             flex-grow: 1;
             overflow: hidden;
             margin-right: 10px;
             /* Make mini player clickable area larger but exclude control button */
             display: flex;
             align-items: center;
         }
        #miniPlayerImage {
            width: 45px;
            height: 45px;
            border-radius: 4px;
            margin-right: 10px;
            object-fit: cover;
            flex-shrink: 0;
        }
        #miniPlayerDetails { /* Added div for text */
            overflow: hidden; /* Prevent text overflow */
        }
        #miniPlayerSongName {
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
         #miniPlayerSongArtist {
             font-size: 0.75em;
             color: var(--text-secondary);
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
         }
        #miniPlayerControls { margin-left: auto; flex-shrink: 0; }
        #miniPlayPauseBtn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.8em;
            cursor: pointer;
             padding: 8px; /* Add padding to make click target easier */
        }

        /* Search Page Styles */
        #searchPage {
             /* Keep this styling, pages now just have padding and scrolling */
        }
        #searchBarContainer { display: flex; margin-bottom: 15px; }
        #searchInput {
            flex-grow: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 20px;
            background-color: var(--tertiary-bg);
            color: var(--text-primary);
            margin-right: 10px;
        }
        #searchCloseBtn { /* Optional: Button to clear/close search */
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5em;
        }

         /* Favourites Page */
         #favouritesPage .empty-favs {
             text-align: center;
             margin-top: 50px;
             color: var(--text-secondary);
         }

        /* Seating Page (Placeholder) */
        #seatingPage {
            text-align: center;
            padding-top: 50px;
        }
        #seatingPage h2 { margin-bottom: 20px; }

         /* Generic Section Title */
         .section-title {
             font-size: 1.2em;
             font-weight: 600;
             margin-bottom: 10px;
             margin-top: 20px;
         }
             .setting-item {
      background: #1f1f1f;
      margin: 10px 0;
      padding: 15px;
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .setting-item i {
      font-size: 20px;
      margin-right: 10px;
    }

    .toggle-switch {
      width: 40px;
      height: 20px;
      background: gray;
      border-radius: 10px;
      position: relative;
      cursor: pointer;
    }

    .toggle-switch::before {
      content: "";
      width: 18px;
      height: 18px;
      background: white;
      position: absolute;
      border-radius: 50%;
      top: 1px;
      left: 2px;
      transition: all 0.3s;
    }

    .toggle-switch.active {
      background: #00c3ff;
    }

    .toggle-switch.active::before {
      left: 20px;
    }

    body.light-mode {
      background-color: #f0f0f0;
      color: black;
    }

    body.light-mode .setting-item {
      background: #ddd;
    }
    /* Color Palette */
    .color-palette {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .color-box {
      width: 30px;
      height: 30px;
      border-radius: 5px;
      cursor: pointer;
      border: 2px solid white;
    }
    #section-title {
    font-size: 26px;
    font-weight: bold;
    background: linear-gradient(90deg, var(--theme-color, #00ffff), var(--theme-second-color, #00d4ff));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    display: inline-block;
}


    </style>
</head>
<body > <audio id="audioPlayer" preload="metadata"></audio>

    <div id="homePage" class="page active">
        <h2 id="greeting">Hello</h2>
        <div id="section-title">Trending Songs</div>
        <div id="trendingHeroLoading" class="loading-indicator active">Loading trending songs...</div>
        <div id="trendingHero" class="horizontal-scroll-list">
             </div>
              <div id="section-title">New Album</div>
              <div id="newAlbumSectionLoading" class="loading-indicator active">New Album......</div>
        <div id="newAlbumSection" class="horizontal-scroll-list">
             </div>
        </div>

    <div id="fullTrendingPage" class="page">
        <h2>All Trending Songs</h2>
        <div id="fullTrendingLoading" class="loading-indicator active">Loading trending songs...</div>
        <ul id="fullTrendingList" class="song-list"></ul>
    </div>

    <div id="searchPage" class="page">
        <h2>Search</h2>
        <div id="searchBarContainer">
            <input type="search" id="searchInput" placeholder="Search for songs, artists, albums...">
            </div>
        <div id="searchLoading" class="loading-indicator">Searching...</div>
        <ul id="searchResults" class="song-list"></ul>
    </div>

    <div id="favouritesPage" class="page">
        <h2>Favourites</h2>
        <div id="favouritesLoading" class="loading-indicator">Loading favourites...</div>
        <ul id="favouritesList" class="song-list"></ul>
         <p class="empty-favs" style="display: none;">No favourite songs yet. Tap the heart icon on the player!</p>
    </div>

     <div id="seatingPage" class="page">
         <h2>Seating</h2>
    <div class="setting-item" id="about">
      <span><i class="bi bi-info-circle"></i> About</span>
      <i class="bi bi-chevron-right"></i>
    </div>

   <div class="setting-item" id="SUZA-Manga">
            <span><i class="bi bi-journal-bookmark"></i>SUZA-Manga-Reader</span>
            <i class="bi bi-chevron-right"></i>
        </div>
        <div class="setting-item" id="SUZA">
            <span><i class="bi bi-camera-reels"></i>SUZA</span>
            <i class="bi bi-chevron-right"></i>
        </div>
        
        <div class="setting-item" id="SUZA-Music">
            <span><i class="bi bi-music-note"></i>SUZA-Music-Player</span>
            <i class="bi bi-chevron-right"></i>
        </div>
        <div class="setting-item" id="SUZA-TV">
            <span><i class="bi bi-tv"></i>SUZA-TV</span>
            <i class="bi bi-chevron-right"></i>
            </div>
    <div class="setting-item">
  <span><i class="bi bi-palette"></i> Change Theme Color</span>
  <input type="color" id="colorPicker" style="margin-left:auto;">
</div>

<div class="color-palette">
  <div class="color-box" style="background-color: #00c3ff;" data-color="#00c3ff"></div>
  <div class="color-box" style="background-color: #ff5722;" data-color="#ff5722"></div>
  <div class="color-box" style="background-color: #4caf50;" data-color="#4caf50"></div>
  <div class="color-box" style="background-color: #e91e63;" data-color="#e91e63"></div>
  <div class="color-box" style="background-color: #ffc107;" data-color="#ffc107"></div>
</div>

<!-- New Hex Code Input -->
<div class="setting-item">
  <span><i class="bi bi-code"></i> Enter Hex Code</span>
  <input type="text" id="hexInput" placeholder="#00c3ff" style="margin-left:auto; width:120px; padding:3px 8px; border-radius:5px; border:none;">
</div>

         </div>

    <div id="playerPage">
         <div id="playerBlurBackground"></div>
        <img id="playerSongImage" src="placeholder.jpg" alt="Album Art" />
        <div id="playerSongDetails">
            <h1 id="playerSongName">Song Title</h1>
            <p id="playerSongArtist">Artist Name</p>
        </div>
        <div id="playerProgressContainer">
            <div id="playerProgressBar"></div>
        </div>
        <div id="playerTimeDisplay">
            <span id="currentTime">0:00</span>
            <span id="totalDuration">0:00</span>
        </div>
        <div id="playerControlsPrimary">
            <button id="prevBtn" class="player-ctrl-btn"><i class="bi bi-skip-start-fill"></i></button>
            <button id="playPauseBtn" class="player-ctrl-btn"><i class="bi bi-play-circle-fill"></i></button>
            <button id="nextBtn" class="player-ctrl-btn"><i class="bi bi-skip-end-fill"></i></button>
        </div>
         <div id="playerControlsSecondary">
             <button id="downloadBtn" class="player-ctrl-btn-secondary"><i class="bi bi-download"></i></button>
             <button id="repeatBtn" class="player-ctrl-btn-secondary"><i class="bi bi-repeat"></i></button>
             <button id="favouriteBtn" class="player-ctrl-btn-secondary"><i class="bi bi-heart"></i></button> </div>
    </div>

    <div id="miniPlayer">
        <img id="miniPlayerImage" src="placeholder.jpg" alt="Mini Album Art" />
        <div id="miniPlayerInfo"> <div id="miniPlayerDetails"> <div id="miniPlayerSongName">Song Title</div>
                 <div id="miniPlayerSongArtist">Artist Name</div>
             </div>
        </div>
        <div id="miniPlayerControls">
            <button id="miniPlayPauseBtn"><i class="bi bi-play-fill"></i></button>
        </div>
    </div>

    <nav class="bottom-nav">
        <button class="nav-button active" data-page="homePage"><i class="bi bi-house-fill"></i></button> <button class="nav-button" data-page="searchPage"><i class="bi bi-search"></i></button>
        <button class="nav-button" data-page="favouritesPage"><i class="bi bi-heart-fill"></i></button> <button class="nav-button" data-page="seatingPage"><i class="bi bi-gear-fill"></i></button> 
        </nav>
    <script>
        // ----- DOM Elements -----
        const audioPlayer = document.getElementById('audioPlayer');
        // Use querySelectorAll for pages and nav buttons to automatically include new ones
        const pages = document.querySelectorAll('.page');
        const navButtons = document.querySelectorAll('.nav-button');

        // Home Page (New)
        // Home Page (New)
const homePage = document.getElementById('homePage');
const trendingHero = document.getElementById('trendingHero'); // Horizontal list container
const trendingHeroLoading = document.getElementById('trendingHeroLoading'); // Loading for hero

// Full Trending Page (Original, potentially less used now)
const fullTrendingPage = document.getElementById('fullTrendingPage');  // Renamed
const fullTrendingList = document.getElementById('fullTrendingList'); // Renamed
const fullTrendingLoading = document.getElementById('fullTrendingLoading'); // Renamed

// New Album Section
const newAlbumSection = document.getElementById('newAlbumSection');
const newAlbumList = document.getElementById('newAlbumList');
const newAlbumLoading = document.getElementById('newAlbumLoading');

// Genre Section
const genreSection = document.getElementById('genreSection');
const genreList = document.getElementById('genreList');
const genreLoading = document.getElementById('genreLoading');

// Top Play Section
const topPlaySection = document.getElementById('topPlaySection');
const topPlayList = document.getElementById('topPlayList');
const topPlayLoading = document.getElementById('topPlayLoading');

// Singer Section
const singerSection = document.getElementById('singerSection');
const singerList = document.getElementById('singerList');
const singerLoading = document.getElementById('singerLoading');

// Top Studio Section
const topStudioSection = document.getElementById('topStudioSection');
const topStudioList = document.getElementById('topStudioList');
const topStudioLoading = document.getElementById('topStudioLoading');// Renamed
         //New album 
        /* const newAlbumPage = document.getElementById('newAlbumPage');
        const newAlbumList = document.getElementById('newAlbumList');
        const newAlbumLoading = document.getElementById('newAlbumLoading');*/

        // Search Page
        const searchPage = document.getElementById('searchPage');
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchLoading = document.getElementById('searchLoading');

        // Favourites Page
        const favouritesPage = document.getElementById('favouritesPage');
        const favouritesList = document.getElementById('favouritesList');
        const favouritesLoading = document.getElementById('favouritesLoading');
         const emptyFavsMessage = favouritesPage.querySelector('.empty-favs');

        // Seating Page (New)
        const seatingPage = document.getElementById('seatingPage');

        // Big Player
        const playerPage = document.getElementById('playerPage');
        const playerBlurBackground = document.getElementById('playerBlurBackground');
        const playerSongImage = document.getElementById('playerSongImage');
        const playerSongDetails = document.getElementById('playerSongDetails'); // Get details container
        const playerSongName = document.getElementById('playerSongName');
        const playerSongArtist = document.getElementById('playerSongArtist');
        const playerProgressContainer = document.getElementById('playerProgressContainer');
        const playerProgressBar = document.getElementById('playerProgressBar');
        const currentTimeEl = document.getElementById('currentTime');
        const totalDurationEl = document.getElementById('totalDuration');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const nextBtn = document.getElementById('nextBtn');
        const prevBtn = document.getElementById('prevBtn');
        const repeatBtn = document.getElementById('repeatBtn');
        const favouriteBtn = document.getElementById('favouriteBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        // Mini Player
        const miniPlayer = document.getElementById('miniPlayer');
        const miniPlayerImage = document.getElementById('miniPlayerImage');
        const miniPlayerInfo = document.getElementById('miniPlayerInfo'); // Get the info div (clickable area)
        const miniPlayerDetails = document.getElementById('miniPlayerDetails'); // Get the details text div
        const miniPlayerSongName = document.getElementById('miniPlayerSongName');
         const miniPlayerSongArtist = document.getElementById('miniPlayerSongArtist');
        const miniPlayPauseBtn = document.getElementById('miniPlayPauseBtn');


        // ----- State Variables -----
        let currentQueue = []; // Array of song objects { id, name, artist, album, url, image }
        let currentSongIndex = -1;
        let currentSong = null; // The currently playing song object
        let favourites = []; // Array of favourite song objects
        let isRepeat = false;
        let activePage = 'homePage'; // Keep track of the visible page (behind the player if active)
        let trendingSongs = []; // Store trending songs separately


        // ----- API Base URL -----
        // !!! IMPORTANT: REPLACE THIS WITH A WORKING API URL !!!
        // The previous URL 'https://jiosaavn-api-privatecvc2.vercel.app' might be down or removed.
        // You need to find a currently operational unofficial JioSaavn API.
        // Search on GitHub for "JioSaavn API" or similar to find alternatives.
        const API_BASE_URL = 'https://jiosaavn-api-privatecvc2.vercel.app';


        // ----- Utility Functions -----
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "0:00"; // Handle negative or NaN
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs < 10 ? "0" : ""}${secs}`;
        }

        // Select best quality image/URL (adjust qualities as needed)
        function getBestUrl(downloadUrls) {
             if (!downloadUrls || downloadUrls.length === 0) return null;
             // Prioritize higher quality
             return downloadUrls.find(q => q.quality === '320kbps')?.link ||
                    downloadUrls.find(q => q.quality === '160kbps')?.link ||
                     downloadUrls.find(q => q.quality === '128kbps')?.link || // Added 128kbps as common
                    downloadUrls.find(q => q.quality === '96kbps')?.link || // Added 96kbps
                    downloadUrls[downloadUrls.length - 1]?.link; // Fallback to highest available
        }

        function getBestImage(images) {
            if (!images || images.length === 0) return 'placeholder.jpg'; // Placeholder image path
             // Prioritize larger sizes
            return images.find(i => i.quality === '500x500')?.link ||
                   images.find(i => i.quality === '150x150')?.link ||
                   images[0]?.link; // Fallback
        }

        // Decode HTML entities more reliably
        function cleanApiText(text) {
             if (!text) return '';
             const doc = new DOMParser().parseFromString(text, 'text/html');
             return doc.documentElement.textContent;
        }

        // ----- Loading Indicators -----
        function showLoading(indicatorElement, show = true) {
            if (indicatorElement) { // Check if element exists
                indicatorElement.classList.toggle('active', show);
            }
        }

        // ----- Page Navigation -----
        function navigateToPage(pageId, pushState = true) {
             // Only navigate if the target page is different from the current active page,
             // UNLESS the big player is currently active (in which case, allow navigation underneath).
             if(activePage === pageId && !playerPage.classList.contains('active')) {
                 // If already on the target page (and player not active), scroll to top instead?
                 if (!playerPage.classList.contains('active')) {
                      window.scrollTo({ top: 0, behavior: 'smooth' });
                 }
                 return; // Do nothing else if already on the page
             }

            activePage = pageId; // Update activePage state variable

            pages.forEach(page => {
                page.classList.toggle('active', page.id === pageId);
            });
            navButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.page === pageId);
            });

             // Manage history state only if pushState is true
             if (pushState) {
                 // Store the page we navigated to, plus the current player state
                  const state = {
                      page: pageId,
                      playerVisible: false, // Navigating to a page implies big player is hidden (unless coming from big player popstate)
                      miniPlayerActive: miniPlayer.classList.contains('active') // Keep current mini player state
                  };
                 history.pushState(state, '', `#${pageId}`); // Add hash for potentially better state management
                  console.log(`History: Pushed state for page ${pageId}`);
             }

            // Load content if needed (only if not already loaded or needs refresh)
             if (pageId === 'favouritesPage') {
                 displayFavourites(); // Always re-render favourites list as it can change
             } else if (pageId === 'homePage' && trendingHero.children.length <= 1) { // Check if trending hero is empty (only loading indicator)
                  // Fetch trending songs if the hero section needs content
                  fetchTrendingSongs();
             } else if (pageId === 'searchPage') {
                  // Optionally clear previous search results when navigating away/to search
                 // searchInput.value = '';
                 // searchResults.innerHTML = '';
                 // searchInput.focus(); // Optionally focus search input
             }
             // fullTrendingPage content loading can be added here if navigating directly to it

             // Don't scroll on page change if player is active - player covers everything
             if (!playerPage.classList.contains('active')) {
                 window.scrollTo({ top: 0, behavior: 'smooth' }); // Smooth scroll to top on page change
             }
        }

        // ----- Favourite Management -----
        function loadFavouritesFromStorage() {
            try {
                const storedFavourites = localStorage.getItem('favourites');
                favourites = storedFavourites ? JSON.parse(storedFavourites) : [];
                console.log("Loaded Favourites:", favourites.length);
            } catch (e) {
                console.error("Error loading favourites from localStorage:", e);
                favourites = []; // Default to empty array on error
            }
        }

        function saveFavouritesToStorage() {
            try {
                localStorage.setItem('favourites', JSON.stringify(favourites));
                 console.log("Saved Favourites:", favourites.length);
            } catch (e) {
                console.error("Error saving favourites to localStorage:", e);
            }
        }

         function isFavourite(songId) {
             return favourites.some(fav => fav.id === songId);
         }

        function toggleFavourite() {
            if (!currentSong) {
                 console.warn("No song loaded to toggle favourite.");
                 return;
            }

            const songId = currentSong.id;
             const favouriteIndex = favourites.findIndex(fav => fav.id === songId);

            if (favouriteIndex > -1) { // Is favourite, remove it
                favourites.splice(favouriteIndex, 1);
                 console.log('Removed from favourites:', currentSong.name);
            } else { // Not favourite, add it
                favourites.push(currentSong); // Add the whole currentSong object
                 console.log('Added to favourites:', currentSong.name);
            }
            saveFavouritesToStorage();

             // Update the heart button icon immediately
             updateFavouriteButton();

             // Refresh favourites list if currently viewing it
             if (activePage === 'favouritesPage') {
                 displayFavourites();
             }
        }

         function updateFavouriteButton() {
             if (!currentSong) {
                 favouriteBtn.innerHTML = '<i class="bi bi-heart"></i>';
                 favouriteBtn.classList.remove('active');
                 return;
             }
             if (isFavourite(currentSong.id)) {
                 favouriteBtn.innerHTML = '<i class="bi bi-heart-fill"></i>'; // Filled heart
                 favouriteBtn.classList.add('active');
             } else {
                 favouriteBtn.innerHTML = '<i class="bi bi-heart"></i>'; // Outline heart
                 favouriteBtn.classList.remove('active');
             }
         }


        // ----- Audio Player Logic -----
        function playSongFromQueue(index) {
            if (!currentQueue || currentQueue.length === 0 || index < 0 || index >= currentQueue.length) {
                console.error("Invalid song index or empty queue:", index);
                 // Stop playback and hide players if queue is invalid
                 audioPlayer.pause();
                 updatePlayPauseButtons(false);
                 currentSong = null; // Clear current song state
                 showMiniPlayer(false); // Hide mini player
                 showPlayerPage(false, false); // Hide big player
                 document.body.classList.remove('mini-player-visible'); // Remove body class
                return;
            }

            // Stop current playback before loading new song
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            updateProgress(); // Reset UI progress

            currentSongIndex = index;
            currentSong = currentQueue[currentSongIndex]; // Store the currently selected song object

            console.log("Attempting to play:", currentSong?.name, "Index:", currentSongIndex, "Queue Length:", currentQueue.length);
             console.log("Song Object:", currentSong); // Log the song object for debugging

             if(!currentSong?.url){ // Check if url exists and is not null/undefined
                 console.error("Song has no valid URL:", currentSong?.name);
                 alert(`Could not play "${currentSong?.name || 'this song'}". No valid URL found.`);
                 // Try playing next song automatically if possible, or handle error state
                 if (currentQueue.length > 1 && index < currentQueue.length - 1) {
                     console.log("Skipping song with no URL, attempting next.");
                     playSongFromQueue(index + 1); // Try the next song
                 } else {
                      // Handle end of queue or single non-playable song
                      console.log("No more songs to play or single non-playable song.");
                      currentSong = null;
                      updatePlayPauseButtons(false);
                      showMiniPlayer(false);
                      showPlayerPage(false, false);
                       document.body.classList.remove('mini-player-visible');
                 }
                 return; // Stop playback attempt for this song
             }

            audioPlayer.src = currentSong.url;
            audioPlayer.load(); // Important for some browsers to load metadata

            // Update UI immediately with new song info
            updatePlayerUI(currentSong);
            updateMiniPlayerUI(currentSong);
            updateFavouriteButton(); // Check if the new song is a favourite

            // Play
            audioPlayer.play().then(() => {
                updatePlayPauseButtons(true); // Playing
                // Show the big player and push its state to history
                showPlayerPage(true, true); // Show big player and push state
                 // Ensure mini player is hidden when big player is active
                showMiniPlayer(false); // This will hide the mini player immediately
                 document.body.classList.remove('mini-player-visible'); // Ensure body class is removed
            }).catch(error => {
                console.error("Audio Play Error:", error);
                updatePlayPauseButtons(false);
                 // Alert user maybe?
                 alert(`Error playing ${currentSong?.name || 'the song'}. It might be protected or unavailable. Details: ${error.message}`);
                 // Could also attempt to skip to the next song here
                 if (currentQueue.length > 1 && index < currentQueue.length - 1) {
                     console.log("Attempting next song after playback error.");
                     playSongFromQueue(index + 1);
                 } else {
                     console.log("No more songs to play or single song error. Clearing player state.");
                     currentSong = null; // Clear state on final error
                      updatePlayerUI({ name: 'Error loading song', artist: ''}); // Clear display
                     showMiniPlayer(false);
                     showPlayerPage(false, false);
                      document.body.classList.remove('mini-player-visible');
                 }
            });
        }

         function updatePlayerUI(song) {
             playerSongImage.src = song?.image || 'placeholder.jpg';
             playerBlurBackground.style.backgroundImage = `url('${song?.image || 'placeholder.jpg'}')`;
             playerSongName.textContent = song?.name || 'Unknown Song';
             playerSongArtist.textContent = song?.artist || song?.album || 'Unknown Artist'; // Use artist first if available
             // Reset progress
             playerProgressBar.style.width = '0%';
             currentTimeEl.textContent = '0:00';
             totalDurationEl.textContent = '0:00'; // Reset duration until metadata loads
         }

         function updateMiniPlayerUI(song) {
             miniPlayerImage.src = song?.image || 'placeholder.jpg';
             miniPlayerSongName.textContent = song?.name || 'Unknown Song';
             miniPlayerSongArtist.textContent = song?.artist || song?.album || 'Unknown Artist';
         }

        function togglePlayPause() {
            if (!currentSong || !audioPlayer.src) {
                 console.warn("No song loaded or src set to play/pause.");
                 return; // No song loaded
            }

            if (audioPlayer.paused || audioPlayer.ended) {
                audioPlayer.play().catch(e => console.error("Play error:", e));
            } else {
                audioPlayer.pause();
            }
             // State update will be handled by 'play' and 'pause' events
        }

        function updatePlayPauseButtons(isPlaying) {
            playPauseBtn.innerHTML = isPlaying ? '<i class="bi bi-pause-circle-fill"></i>' : '<i class="bi bi-play-circle-fill"></i>';
            miniPlayPauseBtn.innerHTML = isPlaying ? '<i class="bi bi-pause-fill"></i>' : '<i class="bi bi-play-fill"></i>';
        }

         function updateProgress() {
             if (isNaN(audioPlayer.duration)) {
                 // console.log("Duration is NaN"); // Can happen before metadata loads
                 return;
             }
             const percentage = (audioPlayer.currentTime / audioPlayer.duration) * 100;
             playerProgressBar.style.width = `${percentage}%`;
             currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
             // Update total duration once available (usually after loadedmetadata)
             // Only update if duration is valid and not already set (or if it was reset to 0:00)
             if (!isNaN(audioPlayer.duration) && audioPlayer.duration > 0 && totalDurationEl.textContent === '0:00') {
                 totalDurationEl.textContent = formatTime(audioPlayer.duration);
             }
         }


        function setProgress(e) {
            // Prevent seeking if no song is loaded or duration is invalid
            if (!currentSong || isNaN(audioPlayer.duration) || audioPlayer.duration === 0) {
                 console.warn("Cannot seek: no song loaded or invalid duration.");
                 return;
            }
            // Get the click position relative to the progress container
            const rect = playerProgressContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left; // Use clientX for position relative to viewport
            const width = rect.width;

            const clickedRatio = Math.max(0, Math.min(1, clickX / width));
            audioPlayer.currentTime = clickedRatio * audioPlayer.duration;
        }

        function playNextSong() {
             if (!currentQueue || currentQueue.length === 0) {
                 console.warn("Cannot play next song, queue is empty.");
                 // Optionally stop playback and hide players
                 audioPlayer.pause();
                 updatePlayPauseButtons(false);
                 currentSong = null;
                 showMiniPlayer(false);
                 showPlayerPage(false, false);
                  document.body.classList.remove('mini-player-visible');
                 return;
             }
            let nextIndex = (currentSongIndex + 1) % currentQueue.length;
             // If currentQueue has only one song and repeat is off, stop instead of repeating
             if (currentQueue.length === 1 && !isRepeat) {
                 audioPlayer.pause();
                 audioPlayer.currentTime = 0;
                 updatePlayPauseButtons(false);
                  // Optionally hide players
                  // showMiniPlayer(false);
                  // showPlayerPage(false, false);
                  // document.body.classList.remove('mini-player-visible');
                 console.log("End of queue (single song, repeat off). Stopping playback.");
                 return; // Stop here if single song and repeat off
             }
            playSongFromQueue(nextIndex);
        }

        function playPrevSong() {
             if (!currentQueue || currentQueue.length === 0) {
                  console.warn("Cannot play previous song, queue is empty.");
                 // Optionally stop playback and hide players
                 audioPlayer.pause();
                 updatePlayPauseButtons(false);
                 currentSong = null;
                 showMiniPlayer(false);
                 showPlayerPage(false, false);
                  document.body.classList.remove('mini-player-visible');
                 return;
             }
            // If played for more than 3 seconds, restart current song, else play previous
            if (audioPlayer.currentTime > 3) {
                audioPlayer.currentTime = 0;
            } else {
                let prevIndex = (currentSongIndex - 1 + currentQueue.length) % currentQueue.length;
                 // If currentQueue has only one song, just restart it
                 if (currentQueue.length === 1) {
                     audioPlayer.currentTime = 0;
                 } else {
                    playSongFromQueue(prevIndex);
                 }
            }
        }

         function toggleRepeat() {
             isRepeat = !isRepeat;
             audioPlayer.loop = isRepeat; // Use native loop property
             repeatBtn.classList.toggle('active', isRepeat);
             console.log("Repeat mode:", isRepeat ? "ON" : "OFF");
             // Update repeat button icon if needed (e.g., repeat-once for single song repeat)
             // For simplicity, keeping the same icon for now.
         }

        function showPlayerPage(show = true, pushState = false) {
            playerPage.classList.toggle('active', show);

             // Manage history state if pushState is true (happens when opening player)
             if (show && pushState) {
                 // When showing the big player, push a new state
                  const state = {
                      page: activePage, // Store the page that was visible underneath
                      playerVisible: true,
                      miniPlayerActive: false // Big player is active, mini player is not
                  };
                 history.pushState(state, '', '#player'); // Use a specific hash for player state
                  console.log("History: Pushed state for player page.");
             }
             // Note: Minimizing the player is handled by the popstate listener
        }

         function showMiniPlayer(show = true) {
            // Only show mini player if a song is loaded AND big player is NOT active
            const shouldShow = show && currentSong && !playerPage.classList.contains('active');
            miniPlayer.classList.toggle('active', shouldShow);
            document.body.classList.toggle('mini-player-visible', shouldShow);
            // History state for mini player is handled by page navigation and popstate
         }


        // ----- API Fetching -----
        async function fetchSongs(endpoint, query = '', loadingElement, listElement, displayFn) {
             console.log(`Attempting fetch from ${API_BASE_URL}${endpoint} with query "${query}"`);
             if (loadingElement) showLoading(loadingElement, true);

             // Clear list content before fetching, handle loading indicator visibility
             if (listElement) {
                 // Remove all children except loading indicator
                 Array.from(listElement.children).forEach(child => {
                     if (loadingElement && child !== loadingElement) {
                          child.remove();
                     } else if (!loadingElement) {
                          child.remove(); // Remove all if no loading indicator specified
                     }
                 });
                 // Add a temporary "Loading..." message if no loadingElement was passed but listElement was
                 if (!loadingElement) {
                      const tempLoading = document.createElement('p');
                      tempLoading.textContent = 'Loading...';
                      tempLoading.style.cssText = 'text-align:center; color: var(--text-secondary); padding: 20px; width: 100%; flex-shrink: 0;';
                       tempLoading.classList.add('temp-loading-message'); // Add class to identify
                      listElement.appendChild(tempLoading);
                 }
             }


            let url = `${API_BASE_URL}${endpoint}`;
             if (query) {
                 url += `?query=${encodeURIComponent(query)}`;
                 // Add limit for search results, maybe a smaller limit for trending hero?
                 url += endpoint.includes('/search/songs') ? `&limit=50` : `&limit=20`; // Limit search results, fewer for hero
             }

             console.log("Fetching:", url);

            try {
                const response = await fetch(url);
                if (!response.ok) {
                     console.error(`HTTP error! status: ${response.status}`, await response.text()); // Log response text on error
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                 console.log("API Response Data:", data);

                 let songs = [];
                 // Attempt to extract song array from common API response structures
                 if(data?.data?.results) { // Search results structure
                     songs = data.data.results;
                 } else if(data?.data?.trending?.songs) { // Hypothetical trending structure for Home page
                     songs = data.data.trending.songs;
                 } else if (Array.isArray(data?.data)) { // Another possible structure for lists
                     songs = data.data;
                 } else if (data?.results) { // Simpler structure?
                      songs = data.results;
                 }
                  // Check for album/playlist structure if needed
                  else if (data?.data?.songs) { songs = data.data.songs; }
                 // Add more checks here if your specific API has a different structure

                 console.log("Extracted songs array length:", songs?.length);


                if (!songs || songs.length === 0) {
                     if (listElement) {
                         // Remove any temporary loading message
                         const tempLoading = listElement.querySelector('.temp-loading-message');
                         if (tempLoading) tempLoading.remove();

                         listElement.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 20px; width: 100%; flex-shrink: 0;">No songs found.</p>';
                     }
                    return [];
                 }

                const processedSongs = songs.map((song) => ({
                    id: song.id,
                    name: cleanApiText(song.name || song.title || 'Unknown Song'),
                    // Try multiple potential artist fields
                    artist: cleanApiText(song.primaryArtists || song.artists?.all_name || song.artist || song.more_info?.artistMap?.primary_artists?.[0]?.name || song.more_info?.artistMap?.featured_artists?.[0]?.name || 'Unknown Artist'),
                    // Try multiple potential album fields
                    album: cleanApiText(song.album?.name || song.album || song.more_info?.album || 'Unknown Album'),
                    // Handle downloadUrl or encrypted_media_url
                    url: getBestUrl(song.downloadUrl || (song.more_info?.encrypted_media_url ? [{ link: song.more_info.encrypted_media_url, quality: 'auto' }] : null)), // Assuming API decrypts encrypted_media_url
                    image: getBestImage(song.image || song.images),
                     raw_data: song // Keep original data just in case
                })).filter(song => song.url); // Filter out songs without a playable URL

                 console.log("Processed songs count (with URLs):", processedSongs.length);


                 if (listElement && displayFn) {
                      // Remove any temporary loading message before displaying results
                      const tempLoading = listElement.querySelector('.temp-loading-message');
                      if (tempLoading) tempLoading.remove();

                      displayFn(processedSongs, listElement, processedSongs); // Pass processedSongs as the queue context
                 }


                return processedSongs; // Return the processed songs

            } catch (error) {
                console.error("Error fetching songs:", error);
                 if (listElement) {
                      // Remove any temporary loading message
                      const tempLoading = listElement.querySelector('.temp-loading-message');
                      if (tempLoading) tempLoading.remove();

                     listElement.innerHTML = `<p style="text-align:center; color: tomato; padding: 20px; width: 100%; flex-shrink: 0;">Failed to load songs. ${error.message}. Check API_BASE_URL and browser console.</p>`;
                 }
                 return [];
            } finally {
                if (loadingElement) showLoading(loadingElement, false);
            }
        }

         async function fetchTrendingSongs() {
             console.log("Fetching trending songs...");
             // Store trending songs globally so the horizontal list can use them as a queue context
             // Using 'trending hindi songs' as a search query, but ideally a dedicated trending endpoint exists.
             trendingSongs = await fetchSongs('/search/songs', 'trending hindi songs', trendingHeroLoading, trendingHero, displayHorizontalSongs);
              console.log("Trending Songs fetched. Count:", trendingSongs.length);
             // Optionally load the full list too, or load it when navigating to the full trending page
             // await fetchSongs('/search/songs', 'trending hindi songs', fullTrendingLoading, fullTrendingList, displaySongs); // Load full list too
         }
         async function performSearch() {
              const query = searchInput.value.trim();
              if (!query) {
                  searchResults.innerHTML = ''; // Clear results if search box is empty
                  showLoading(searchLoading, false);
                  return;
              }
              searchResults.innerHTML = ''; // Clear previous results immediately
              console.log("Performing search for:", query);
              const searchResultSongs = await fetchSongs('/search/songs', query, searchLoading, searchResults, displaySongs);
              console.log("Search results count:", searchResultSongs.length);
              // The displaySongs function for searchResults will set currentQueue when an item is clicked.
         }


        // ----- UI Display Functions -----

        // For vertical lists (Search, Favourites, Full Trending)
        function displaySongs(songs, listElement, queueContext) {
             listElement.innerHTML = ''; // Clear previous content before adding new items
            if (!songs || songs.length === 0) {
                 // Message is handled by fetchSongs now
                return;
            }

            songs.forEach((song, index) => {
                const li = document.createElement('li');
                li.className = 'song-item';
                li.innerHTML = `
                    <img src="${song.image}" alt="${song.name}" loading="lazy" onerror="this.onerror=null; this.src='placeholder.jpg';"> <div class="song-info">
                        <div class="song-name">${song.name}</div>
                        <div class="song-artist">${song.artist}</div>
                    </div>
                     ${listElement === favouritesList ? `<button class="remove-fav-btn" data-id="${song.id}" title="Remove favourite"><i class="bi bi-trash"></i></button>` : ''}
                `;

                 // Add click listener to the whole item
                 li.addEventListener('click', (e) => {
                     // Check if the click was specifically on the remove button (if it exists)
                     if (listElement === favouritesList && e.target.closest('.remove-fav-btn')) {
                         return; // Do nothing if remove button was clicked
                     }
                      // When a song item is clicked, set the currentQueue to the provided context
                     currentQueue = queueContext; // Set the active queue for navigation (next/prev)
                      console.log(`Clicked vertical list song: ${song.name}, Index: ${index}, Queue length: ${currentQueue.length}`);
                     playSongFromQueue(index); // Play the song
                 });

                 // Add specific listener for the remove button if it exists
                 if (listElement === favouritesList) {
                     const removeBtn = li.querySelector('.remove-fav-btn');
                     if (removeBtn) {
                         removeBtn.onclick = (e) => {
                              e.stopPropagation(); // Prevent the li click listener from firing
                              const songIdToRemove = e.currentTarget.dataset.id;
                              const favIndexToRemove = favourites.findIndex(fav => fav.id === songIdToRemove);
                              if(favIndexToRemove > -1) {
                                  favourites.splice(favIndexToRemove, 1);
                                  saveFavouritesToStorage();
                                  displayFavourites(); // Re-render the list
                                   // Also update the heart icon on the main player if the removed song is currently playing
                                   if(currentSong && currentSong.id === songIdToRemove) {
                                       updateFavouriteButton(); // Update icon to unfavourited
                                   }
                              }
                         };
                     }
                 }

                listElement.appendChild(li);
            });
        }

        // For horizontal lists (Home page hero)
        function displayHorizontalSongs(songs, containerElement, queueContext) {
             // Keep the loading indicator if present, remove other items
             Array.from(containerElement.children).forEach(child => {
                 if (trendingHeroLoading && child !== trendingHeroLoading) { // Check specifically for the hero loading indicator
                      child.remove();
                 } else if (!trendingHeroLoading) { // If no loading indicator expected, remove all
                     child.remove();
                 }
             });

            if (!songs || songs.length === 0) {
                 const noSongsMsg = document.createElement('p');
                 noSongsMsg.style.cssText = 'text-align:center; color: var(--text-secondary); padding: 20px; width: 100%; flex-shrink: 0;';
                 noSongsMsg.textContent = 'No trending songs found.';
                 containerElement.appendChild(noSongsMsg);
                 return;
            }

            songs.forEach((song, index) => {
                const item = document.createElement('div'); // Use div for horizontal item
                item.className = 'horizontal-scroll-item';
                item.innerHTML = `
                    <img src="${song.image}" alt="${song.name}" loading="lazy" onerror="this.onerror=null; this.src='placeholder.jpg';"> <div class="song-name">${song.name}</div>
                    <div class="song-artist">${song.artist}</div>
                `;
                item.onclick = () => {
                     // When a horizontal item is clicked, set the currentQueue to the provided context
                     // (which for the trending hero is the trendingSongs array)
                     currentQueue = queueContext; // Set the active queue
                      console.log(`Clicked horizontal song: ${song.name}, Index: ${index}, Queue length: ${currentQueue.length}`);
                    playSongFromQueue(index); // Play the song using its index within that queue context
                };
                containerElement.appendChild(item);
            });
        }


         function displayFavourites() {
             showLoading(favouritesLoading, true);
             favouritesList.innerHTML = ''; // Clear list before populating

             if (favourites.length === 0) {
                 emptyFavsMessage.style.display = 'block';
             } else {
                 emptyFavsMessage.style.display = 'none';
                 // Use the generic displaySongs function, passing favourites as the queue context
                 displaySongs(favourites, favouritesList, favourites);
             }
             showLoading(favouritesLoading, false);
         }


    // ----- Event Listeners -----

        // Navigation
        navButtons.forEach(button => {
            button.addEventListener('click', () => {
                navigateToPage(button.dataset.page, true); // Push state on nav click
            });
        });

        // Player Controls
        playPauseBtn.addEventListener('click', togglePlayPause);
        miniPlayPauseBtn.addEventListener('click', togglePlayPause);
        nextBtn.addEventListener('click', playNextSong);
        prevBtn.addEventListener('click', playPrevSong);
        repeatBtn.addEventListener('click', toggleRepeat);
        favouriteBtn.addEventListener('click', toggleFavourite);
        playerProgressContainer.addEventListener('click', setProgress);
         // Download Button (Example - opens URL in new tab, actual download is complex)
         downloadBtn.addEventListener('click', () => {
             if (currentSong && currentSong.url) {
                  // Attempt to trigger download - may not work universally due to headers/CORS
                 const link = document.createElement('a');
                 link.href = currentSong.url;
                 // Provide a better filename if possible
                 link.setAttribute('download', `${currentSong.name || 'song'} - ${currentSong.artist || 'artist'}.mp3`);
                 document.body.appendChild(link);
                 link.click();
                 document.body.removeChild(link);
                 console.log("Attempted download for:", currentSong.name);

             } else {
                 alert("No song loaded or song has no download URL.");
             }
         });


        // Audio Events
        audioPlayer.addEventListener('play', () => {
             console.log("Audio player 'play' event.");
             updatePlayPauseButtons(true);
        });
        audioPlayer.addEventListener('pause', () => {
             console.log("Audio player 'pause' event.");
             updatePlayPauseButtons(false);
        });
        audioPlayer.addEventListener('ended', () => {
            console.log("Audio player 'ended' event. Repeat:", isRepeat);
            if (!isRepeat) { // Play next only if repeat is off
                playNextSong();
            } else {
                 // If loop attribute is set (repeat is true), the audio element will loop automatically
                 console.log("Looping current song.");
            }
        });
        audioPlayer.addEventListener('timeupdate', updateProgress);
         audioPlayer.addEventListener('loadedmetadata', () => {
             console.log("Audio player 'loadedmetadata' event. Duration:", audioPlayer.duration);
             updateProgress(); // Update progress bar immediately
             // Update total duration once available and valid
             if (!isNaN(audioPlayer.duration) && audioPlayer.duration > 0) {
                  totalDurationEl.textContent = formatTime(audioPlayer.duration);
             } else {
                 totalDurationEl.textContent = '0:00'; // Reset or placeholder if invalid
             }
         });
          audioPlayer.addEventListener('waiting', () => {
               console.log("Audio player 'waiting' event (buffering).");
               // Optionally show buffering indicator
          });
          audioPlayer.addEventListener('playing', () => {
               console.log("Audio player 'playing' event (no longer waiting).");
               // Optionally hide buffering indicator
          });
         audioPlayer.addEventListener('error', (e) => {
             console.error('Audio Player Error Event:', e.message, e.code, e.target.error);
             updatePlayPauseButtons(false);
              let errorMessage = 'An error occurred during audio playback.';
             switch (e.target.error.code) {
                case MediaError.MEDIA_ERR_ABORTED: errorMessage = 'Playback aborted.'; break;
                case MediaError.MEDIA_ERR_NETWORK: errorMessage = 'Network error.'; break;
                case MediaError.MEDIA_ERR_DECODE: errorMessage = 'Audio decoding error.'; break;
                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMessage = 'Audio format not supported.'; break;
                 default: errorMessage = 'An unknown audio error occurred.'; break;
             }
             alert(`${errorMessage} Song: ${currentSong?.name || 'Unknown'}`);

             // Attempt to play the next song automatically after an error
             if (currentQueue.length > 1 && currentSongIndex < currentQueue.length - 1) {
                 console.log("Attempting to skip to next song after error.");
                 playSongFromQueue(currentSongIndex + 1);
             } else {
                 console.log("No more songs to play or single song error. Clearing player state.");
                 currentSong = null; // Clear current song on final error
                 updatePlayerUI({ name: 'Error loading song', artist: ''}); // Clear display
                 showMiniPlayer(false);
                 showPlayerPage(false, false);
                  document.body.classList.remove('mini-player-visible');
             }
         });


        // Mini Player Click -> Show Big Player
         // Attach click listener to the miniPlayerInfo div (image and details)
        miniPlayerInfo.addEventListener('click', (e) => {
             // Check if a song is loaded
             if (currentSong) {
                 console.log("Mini player info area clicked, showing big player.");
                 showPlayerPage(true, true); // Show big player and push state
                 showMiniPlayer(false); // Hide mini player
             } else {
                 console.log("Mini player info area clicked but no song is loaded.");
             }
        });
         // Attach click listener to the miniPlayerImage directly as well
         miniPlayerImage.addEventListener('click', (e) => {
              if (currentSong) {
                  console.log("Mini player image clicked, showing big player.");
                  showPlayerPage(true, true); // Show big player and push state
                  showMiniPlayer(false); // Hide mini player
              } else {
                  console.log("Mini player image clicked but no song is loaded.");
              }
         });


        // Search Input
         let searchDebounceTimeout;
         searchInput.addEventListener('input', () => {
             clearTimeout(searchDebounceTimeout);
             // Only perform search if the query is not empty after debounce
             if (searchInput.value.trim().length > 0) {
                 searchDebounceTimeout = setTimeout(performSearch, 500); // Debounce search by 500ms
             } else {
                 // Clear results if input is empty
                 searchResults.innerHTML = '';
                 showLoading(searchLoading, false);
             }
         });
         searchInput.addEventListener('keypress', (e) => { // Also allow Enter key
            if (e.key === 'Enter') {
               clearTimeout(searchDebounceTimeout); // Cancel debounce if Enter pressed
                if (searchInput.value.trim().length > 0) {
                   performSearch();
                }
            }
        });

        // Handle Back Button (Popstate) for Minimizing Player and Navigation
        // Use history.replaceState on load to set a clean initial state
        // This state represents the default page view with no player active.
        // It's crucial that the initial state represents a PAGE, not the player,
        // so the first back press from a page doesn't try to minimize a non-existent player.
        history.replaceState({ page: 'homePage', playerVisible: false, miniPlayerActive: false }, '', '#homePage');

        window.addEventListener('popstate', (event) => {
            const state = event.state;
            console.log("--- Popstate event ---");
            console.log("State received:", state);
            console.log("Current UI active page:", activePage); // activePage is the page *behind* player
            console.log("Current UI Big Player active:", playerPage.classList.contains('active'));

            // Check if the big player was active in our UI *just before* this popstate fired.
            // We deduce this based on whether the big player is currently visible.
            if (playerPage.classList.contains('active')) {
                console.log("Popstate handling: Big player was active. Minimizing...");
                // The user pressed back while the big player was showing.
                // We need to minimize the player.
                showPlayerPage(false, false); // Hide big player, do NOT push state (browser already popped)
                showMiniPlayer(true); // Show mini player

                // IMPORTANT: Push a new state representing the state *after* minimizing.
                // The browser *already* moved back one step in history (from the big player state to the state BEFORE it, which should be the page state).
                // We are essentially replacing the state that the browser popped *to* with a state that represents the *same page*, but with the *mini player visible*.
                // We use the 'activePage' variable because it holds the ID of the page that was visible *behind* the player.
                 const newState = { page: activePage, playerVisible: false, miniPlayerActive: true };
                 history.pushState(newState, '', `#${activePage}`);
                 console.log("History: Pushed new state after minimizing player:", newState);

                 // We've handled the back action internally by changing the UI and history state.
                 // No need to preventDefault if we pushed a new state.

            } else {
                // The big player was NOT active. This popstate is for regular page navigation or exiting.
                // The browser's default history handling has already navigated to the state in `event.state`.
                // We just need to update our UI to match the state that was popped *to*.
                if (state && state.page) {
                    console.log("Popstate handling: Big player was NOT active. Navigating to page:", state.page, "Mini player active:", state.miniPlayerActive);
                     // This was a page navigation within our app history handled by a previous pushState.
                     // Update the UI based on the state received from history.
                     // Use `MapsToPage` with `pushState = false` because the browser already handled the history change.
                     navigateToPage(state.page, false);
                     showMiniPlayer(state.miniPlayerActive); // Restore mini player state based on the history state

                } else {
                     // This might be the very first state (state is null or undefined) or an external navigation/exit.
                     // Let default browser behavior handle it (e.g., exiting the app or going to the truly previous page).
                     console.log("Popstate handling: Default browser behavior or initial state reached (state is null or missing page).");
                     // We don't prevent default, letting the browser proceed.
                }
            }
            console.log("--- End Popstate event ---");
        });


        // ----- Initial Load -----
        function initializeApp() {
            console.log("Initializing App...");
            loadFavouritesFromStorage(); // Load favs first

            // Determine the initial page based on URL hash or default
            const initialHash = window.location.hash;
            let targetPage = 'homePage'; // Default page

             if (initialHash && initialHash.startsWith('#')) {
                const hashId = initialHash.substring(1);
                 // Check if the hash matches a known page ID
                 const validPageHash = Array.from(pages).some(page => page.id === hashId);
                 // We don't attempt to restore the player state purely from the #player hash on initial load
                 // as we wouldn't know which song was playing.

                if (validPageHash) {
                    targetPage = hashId;
                } else if (hashId === 'player') {
                     // If deep-linked directly to #player, just go to the default page
                     console.warn("Deep-linked to #player without saved state. Navigating to home.");
                     targetPage = 'homePage';
                }
             }

            // Set the initial history state using replaceState.
            // This state represents the starting page view with no player active initially.
            // This is crucial so the *first* back button press from this state might exit the app
            // or go to the page *before* this app was opened, which is standard browser behavior.
             const initialHistoryState = { page: targetPage, playerVisible: false, miniPlayerActive: false };
             history.replaceState(initialHistoryState, '', `#${targetPage}`);
             console.log("History: Set initial state:", initialHistoryState);


            // Navigate to the determined initial page without pushing a new state again
            navigateToPage(targetPage, false);

            // Fetch initial content for the default page (Home)
            if (targetPage === 'homePage') {
                 fetchTrendingSongs(); // Load trending songs for the Home page hero
            }
            // Add other initial fetches here if needed for different starting pages


             // Ensure players are hidden initially until a song is explicitly played
             showPlayerPage(false, false); // Ensure big player is hidden
             showMiniPlayer(false); // Ensure mini player is hidden
             document.body.classList.remove('mini-player-visible'); // Ensure body class is clean

             // Ensure play/pause buttons show 'play' initially
             updatePlayPauseButtons(false);

             // Ensure repeat button is not active initially
             repeatBtn.classList.remove('active');
             isRepeat = false; // Sync JS state

             // Ensure favourites button is not active initially if no song is loaded
             updateFavouriteButton();

             console.log("App Initialized.");

        }

        // Start the application
        initializeApp();
        
        
        
        
function applyThemeColor(color) {
  document.documentElement.style.setProperty('--theme-color', color);

  document.querySelectorAll('.nav-link').forEach(el => el.style.color = color);

  const currentPage = window.location.pathname.split('/').pop();
  if (currentPage === 'settings.html') {
    document.getElementById("gear-icon").style.color = color;
  } else {
    document.querySelectorAll('.nav-link i').forEach(function (icon) {
      if (icon.closest('a').getAttribute('href') === 'settings.html') {
        icon.style.color = color;
      } else {
        icon.style.color = 'white';
      }
    });
  }
}

// Load from localStorage on page load
window.addEventListener('load', function () {
  const savedColor = localStorage.getItem("themeColor");
  if (savedColor) applyThemeColor(savedColor);
});

// Color Picker Input
document.getElementById("colorPicker").addEventListener("input", function (e) {
  const color = e.target.value;
  localStorage.setItem("themeColor", color);
  applyThemeColor(color);
});

// Predefined Palette
document.querySelectorAll('.color-box').forEach(function (box) {
  box.addEventListener('click', function () {
    const color = this.getAttribute('data-color');
    localStorage.setItem("themeColor", color);
    applyThemeColor(color);
  });
});

// Hex Input
document.getElementById("hexInput").addEventListener("keypress", function (e) {
  if (e.key === "Enter") {
    const hexColor = e.target.value.trim();
    if (/^#([0-9A-Fa-f]{6})$/.test(hexColor)) {
      localStorage.setItem("themeColor", hexColor);
      applyThemeColor(hexColor);
    } else {
      alert("Please enter a valid Hex code (e.g., #ff0000)");
    }
  }
});
        
        document.getElementById("SUZA-Manga").addEventListener("click", function () {
    window.location.href = "manga/manga.html";
});
        document.getElementById("SUZA").addEventListener("click", function () {
    window.location.href = "home.html";
});
        document.getElementById("SUZA-TV").addEventListener("click", function () {
    window.location.href = "suzaTV/suzatvhome.html";
});
    document.getElementById("SUZA-Music").addEventListener("click", function () {
    window.location.href = "suzaM.html";
});
document.querySelectorAll('#playerControlsPrimary i').forEach(icon => {
    icon.style.background = 'linear-gradient(90deg, var(--theme-color, #00ffff), var(--theme-second-color, #00d4ff))';
    icon.style.webkitBackgroundClip = 'text';
    icon.style.webkitTextFillColor = 'transparent';
});
  const greetingElement = document.getElementById("greeting");
  const currentHour = new Date().getHours();
  let greetingText = "Hello";

  if (currentHour >= 5 && currentHour < 12) {
    greetingText = "Good morning";
  } else if (currentHour >= 12 && currentHour < 17) {
    greetingText = "Good afternoon";
  } else if (currentHour >= 17 && currentHour < 21) {
    greetingText = "Good evening";
  } else {
    greetingText = "Good night";
  }

  greetingElement.textContent = greetingText;
</script>
     
</body>
</html>
